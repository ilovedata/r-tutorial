[["index.html", "R 을 이용한 데이터 과학 입문 제 1 장 서론", " R 을 이용한 데이터 과학 입문 서울시립대학교 통계학과 이용희 2022-01-08 제 1 장 서론 R을 사용하여 데이터를 다루는 방법을 소개하는 교과서입니다. \\[ y =f(x) \\] 이 책에서 이용한 패키지의 목록은 다음과 같습니다. library(knitr) library(tidyverse) library(readxl) "],["intro.html", "제 2 장 R 소개 2.1 통계패키지 R 2.2 R 다운로드 받기 2.3 Rstudio 다운로드 받기", " 제 2 장 R 소개 2.1 통계패키지 R R은 통계계산과 그래픽을 위한 프로그램 언어(program language)이다. R은 프로그램 언어이지만 대화형식(Interactive)으로 실행할 수 있으며 GUI(Graphic User Interface)와 여러 패키지를 포함한 통계분석 시스템을 지칭한다. R은 기본적인 통계 계산과 그래픽 기능이 내장되어 있으며 사용자들이 만든 다양한 패키지(packge)를 자유롭게 이용할 수 있다. R home page 2.2 R 다운로드 받기 R은 무료로 배포하는 통계 계산 및 분석 패키지이다. R 홈페이지 에서 다운로드 받을 수 있다. 일단 R 홈페이지에 들어가면 왼쪽 상단에 Download 메뉴 하단에 CRAN 을 클릭하면 프로그램을 다운로드받을 수 있는 페이지로 이동한다. 그림 2.1: R 홈페이지 다운로드 페이지로 이동하기 전에 R을 다운로드받을 수 있는 서버(server)를 선택하라는 화면이 뜨는데 처음 2개의 클라우드 서버 중에 아무거나 하나를 선택하면 된다. 그림 2.2: 클라우드 서버의 선택 이제 다운로드 페이지에 들어가면 아래와 같은 화면이 뜨는데 자신이 사용하는 컴퓨터 운영체제(Linux, Mac, Windows)중에 하나를 선택하면 된다. 그림 2.3: 운영체제의 선택 Windows 운영체제를 선택하면 다음과 같은 화면으로 이동하며 가장 상단의 base를 클릭한다. 그림 2.4: Windows 운영체제의 선택 후 base 선택 이제 다운로드 페이지에서 R 프로그램을 클릭하여 설치 프로그램을 다운로드받아서 보통의 프로그램과 같이 실행화일을 클릭하여 안내에 따라 설치하면 된다. 그림 2.5: R 설치 화일의 다운로드 2.3 Rstudio 다운로드 받기 Rstudio는 R 언어 작업을 쉽고 효울적으로 할 수 있는 통합개발환경을 제공해주는 프로그램이다. Rstudio 다운로드 페이지에 가서 설치 프로그램을 다운로드받아서 설치할 수 있다. RStudio Desktop (Open Source License) 무료 버젼을 선택하고 자신이 사용하는 운영체제에 따라 설치프로그램을 받아 설치한다. 그림 2.6: RStudio Desktop 무료 Windows 64 bit 버젼 다운로드 다운로드한 설치 프로그램을 통하여 Rstudio를 설치하고 실행하면 다음과 같은 화면이 나타난다. 그림 2.7: RStudio 화면 Rstudio의 화면은 위에서 본것과 같이 4개의 영역으로 분할되어 나타나는데 각각의 영역은 다음과 같은 기능을 가진다. source : R 프로그램이 저장된 화일(확장자는 .R)을 새로 만들거나 불러와서 편집할 수 있으며 명령문을 직접 실행할 수 있다. 실행할 명령문으로 커서를 옮긴 다음 ctrl-enter 키를 누르면 그 결과가 console 화면에 출력된다. console : 대화창(Interactive mode)에서 직접 R 명령어를 입력할 수 있다. 대화창은 &gt; 표시가 있으며 이를 프롬프트(prompt)라고 하며 여기서 명령어를 입력하고 enter를 치면 곧바로 결과를 얻을 수 있는 환경을 제공한다. environment : R 명령어를 실행하면서 생긴 객체들의 현황을 보여주고 또한 지난 명령어의 목록(history)를 보여준다. plot: 그림의 결과를 출력하여 보여주고 package를 설치하고 그 현황을 보여준다. 또한 R언어와 package의 도움말이 제공된다. "],["basic.html", "제 3 장 R 기초 3.1 R 의 계산기 기능 3.2 기본 수학함수 3.3 도움말 3.4 벡터 3.5 벡터에 대한 함수의 적용 3.6 간단한 그림 그리기", " 제 3 장 R 기초 3.1 R 의 계산기 기능 간단한 명령을 몇 가지 살펴보자. 1+1 ## [1] 2 4*3 ## [1] 12 5/2 ## [1] 2.5 3^2 ## [1] 9 결과를 보면 알 수 있겠지만 +는 덧셈, -는 뻴셈, *는 곱셈, /는 나눗셈이며 ^은 거듭제곱을 뜻한다. 계산 순서는 수학과 마찬가지로 괄호친 부분, 거듭제곱, 곱셈과 나눗셈, 덧셈과 뺄셈 순서로 왼쪽부터 계산한다. # 표시가 붙으면 이하의 내용은 주석(comment)으로서 무시한다. # 주석문은 실행되지 않는다. 1 + 1 # 1과 1을 더한다 ## [1] 2 R은 변수(variable)에 값을 할당(assign)할 수 있다 ( = 또는 &lt;-). 아래에서 x, y 등이 변수이다. 변수 이름은 알파벳과 숫자, 그리고 밑줄(_)과 마침표(.)로 지을 수 있으나 첫 글자는 알파벳으로 시작해야 한다. x = 1 y = 2 x + y ## [1] 3 x &lt;- 1 y &lt;- sqrt(3) x + y ## [1] 2.732051 변수에 저장할 수 있는 값은 숫자뿐만이 아니라 문자열도 저장할 수 있다. 문자열은 따옴표(\" \")안에 문자를 넣어 만들 수 있다. t1 &lt;- &quot;R은 통계 패키지이다&quot; t2 &lt;- &quot;My name is Tom &quot; 3.2 기본 수학함수 사칙연산 외의 다른 계산들은 함수를 이용한다. 예를 들어 양의 제곱근을 구하려면 sqrt 함수를 쓴다. 그 외에도 자주 쓰이는 함수로 abs, exp, log가 있다. abs는 절대값, exp는 \\(e^x\\), log는 로그값을 구한다. sqrt(2) ## [1] 1.414214 abs(-3) ## [1] 3 exp(1) ## [1] 2.718282 log(2) ## [1] 0.6931472 함수에는 기본값으로 설정된 부분들이 있다. 예를 들어 log 함수의 밑은 e가 기본값이다. 다시 말해 자연로그를 구한다. 만약 \\(\\log_3(2)\\)를 구하고 싶다면 다음과 같이 밑을 지정해준다. log(2, base=3) ## [1] 0.6309298 3.3 도움말 “?함수이름”과 같은 형식으로 입력하면 함수에 대한 도움말 창이 뜬다. R의 도움말은 매우 자세하고 대부분 예제를 제공하기 때문에 도움말을 읽어보고 예제를 따라해보면 특별한 교재없이도 많은 공부가 된다. 도움말은 Rstudio은 plot 패널에서 help 탭(tab)을 선택하고 찾고자 하는 명령어를 입력하면 그에 대한 도움말을 보여준다. ?log 만약 함수 이름 자체를 모를 때는 help.search 함수를 이용해 도움말을 검색한다. help.search(&quot;logarithm&quot;) 3.4 벡터 R은 통계용 언어이므로 하나의 값을 다루는 경우보다 여러 개의 값을 한 번에 다뤄야하는 경우가 더 많다. 여러 개의 값을 나타내는 방법에는 벡터(vector), 리스트(list), 행렬(matrix), 데이터프레임(dataframe) 등 다양한 구조의 객체들이 있다. 가장 기본적인 객체로서 여러 개의 자료를 나타내는 구조는 벡터로서 여러 개의 동일한 형식의 값들을 모아놓은 자료의 구조이다. 벡터는 c 함수를 이용해 만든다. c(1,2,3) ## [1] 1 2 3 c(1,2,3,4,5) ## [1] 1 2 3 4 5 c(&quot;Tom&quot;, &quot;Jane&quot;,&quot;철수&quot;,&quot;영희&quot;) ## [1] &quot;Tom&quot; &quot;Jane&quot; &quot;철수&quot; &quot;영희&quot; 하나의 값과 벡터를 사칙연산을 하면 하나의 값이 벡터의 각 값에 반복해서 자동적으로 연산을 한다. 1 + c(1,2,3) ## [1] 2 3 4 벡터끼리 사칙연산을 하면 두 벡터에서 같은 위치에 있는 값끼리 연산을 한다. c(1,2,3) + c(4,5,6) ## [1] 5 7 9 두 벡터의 길이가 다르면 짧은 쪽을 반복하여 처음부터 다시 적용한다. 아래 첫 번째 예의 경우 1+3, 1+4를 하고 5와 6에는 다시 1과 2를 적용해서 계산을 한다. 긴 벡터의 길이가 짧은 벡터의 길이의 배수인 것이 원칙이지만 그렇지 않더라도 경고(warning)만 뜰 뿐 계산은 된다. c(1,2) + c(3,4,5,6) ## [1] 4 6 6 8 c(1,2,3) + c(4,5,6,7) ## Warning in c(1, 2, 3) + c(4, 5, 6, 7): longer object length is not a multiple of ## shorter object length ## [1] 5 7 9 8 위의 결과를 보면 연산을 수행할 때 길이가 다른 벡터를 사용할 때는 원하지 않는 결과가 발생할 수 있으므로 주의가 필요하다. 1,2,3,4..와 같이 순서대로 이어지는 정수열은 “시작:끝”과 같은 형태로 콜론(:)을 이용해서 벡터를 만들 수 있다. 1:5 ## [1] 1 2 3 4 5 3:9 ## [1] 3 4 5 6 7 8 9 콜론 대신 seq 함수를 사용할 수 있다. seq(끝), seq(시작,끝), seq(시작, 끝, 간격)과 같은 형태로 사용한다. seq(10) ## [1] 1 2 3 4 5 6 7 8 9 10 seq(3,7) ## [1] 3 4 5 6 7 seq(0,1,0.1) ## [1] 0.0 0.1 0.2 0.3 0.4 0.5 0.6 0.7 0.8 0.9 1.0 seq(10,1) ## [1] 10 9 8 7 6 5 4 3 2 1 같은 수가 반복되는 벡터를 만들 때는 rep 함수를 사용한다. rep(값, 회수)라고 하면 값을 회수만큼 반복한다. rep(벡터, 회수)라고 하면 벡터를 회수만큼 반복한다. rep(벡터, 벡터)라고 하면 왼쪽 벡터에 있는 값을 오른쪽 벡터에 있는 같은 자리의 회수만큼 반복한다. length 옵션을 주면 반복해서 해당 길이만큼 되도록 한다. rep(1,5) ## [1] 1 1 1 1 1 rep(1:3, 3) ## [1] 1 2 3 1 2 3 1 2 3 rep(1:3, 1:3) ## [1] 1 2 2 3 3 3 rep(1:3, length=10) ## [1] 1 2 3 1 2 3 1 2 3 1 당연히 벡터도 변수에 할당할 수 있다. v = c(1,2,3) 벡터에서 위치로 한 값을 지정하고 싶으면 “변수이름[위치]”와 같은 표현을 사용한다. 위치는 벡터에 저장된 값들이 순서대로 1부터 시작하여 저장된 값의 개수까지 자연수로 표시된다. 만약 위치가 벡터의 길이를 초과하면 “값 없음(not available)”을 뜻하는 NA 표시가 뜬다. w &lt;- c(&quot;Tom&quot;, &quot;Jane&quot;,&quot;철수&quot;,&quot;영희&quot;) w ## [1] &quot;Tom&quot; &quot;Jane&quot; &quot;철수&quot; &quot;영희&quot; w[1] ## [1] &quot;Tom&quot; w[4] ## [1] &quot;영희&quot; w[5] ## [1] NA 위치는 하나의 값이 아니라 여러 개의 숫자로 동시에 나타낼 수 있다. w[c(2,4)] ## [1] &quot;Jane&quot; &quot;영희&quot; abc &lt;- 1:10 abc ## [1] 1 2 3 4 5 6 7 8 9 10 abc[1] ## [1] 1 abc[1:5] ## [1] 1 2 3 4 5 abc[c(2,4,6,8)] ## [1] 2 4 6 8 벡터를 만드는 경우 주의할 점은 벡터는 같은 형식의 값들로 구성되어야 한다. 예를 들어 기본적으로 문자열과 숫자로 벡터를 만들 수 없다. 만약 아래와 같이 실수 0.1과 문자열 \"Tom\" 으로 벡터를 만들면 숫자 0.1234 이 문자열로 자동적으로 변환된다. 이러한 자동 변환은 가끔 편리할 수 있지만 예상하지 않은 결과를 초래할 수 있으므로 주의해야 한다. t3 &lt;- c(0.1234, &quot;Tom&quot;) t3 ## [1] &quot;0.1234&quot; &quot;Tom&quot; 3.5 벡터에 대한 함수의 적용 하나의 값에 적용하는 함수를 벡터에 적용하면 사칙 연산의 경우와 마찬가지로 각각의 값에 적용한다. v &lt;- 1:10 v ## [1] 1 2 3 4 5 6 7 8 9 10 log(v) ## [1] 0.0000000 0.6931472 1.0986123 1.3862944 1.6094379 1.7917595 1.9459101 ## [8] 2.0794415 2.1972246 2.3025851 벡터에 적용할 때 하나의 값을 계산하는 함수도 있다. 아래 mean은 벡터의 평균을 구하는 함수이다. mean(v) ## [1] 5.5 sd(v) ## [1] 3.02765 sum(v) ## [1] 55 min(v) ## [1] 1 max(v) ## [1] 10 summary(v) ## Min. 1st Qu. Median Mean 3rd Qu. Max. ## 1.00 3.25 5.50 5.50 7.75 10.00 위에서 나오는 여러 가지 함수는 벡터의 기초 통계량을 계산하는 함수들이다. mean: 평균 sd : 표준편차(standard deviation) sum: 합계 min: 최소값 max: 최대값 summary : 벡터의 요약 정보 (최소값, 1사분위수, 중앙값, 평균, 3사분위수, 최대값) 3.5.1 데이타프레임 데이타프레임(dataframe)은 여러 벡터들을 하나로 합쳐놓은 자료의 형태를 가진다. 흔히 사용하는 마이트로소프트사의 엑셀(MS Excel)에서 사용하는 스프레드쉬트(spread sheet) 형태를 가지는 자료이다. 데이타프레임을 만드는 방법은 먼저 프레임에 포함될 같은 길이를 가지는 벡터들을 만들고 data.frame함수로 데이타프레임을 만들 수 있다. a &lt;- 1:5 a ## [1] 1 2 3 4 5 b &lt;- c(&quot;철이&quot;,&quot;John&quot;,&quot;순이&quot;,&quot;Paul&quot;,&quot;영희&quot;) b ## [1] &quot;철이&quot; &quot;John&quot; &quot;순이&quot; &quot;Paul&quot; &quot;영희&quot; c &lt;-rnorm(5,100,10) # 5 random numbers from Normal distribution N(100,10^2) c ## [1] 99.66793 110.84859 98.11399 78.60413 88.77826 dat &lt;- data.frame(ID=a, Name=b, Salary=c) dat ## ID Name Salary ## 1 1 철이 99.66793 ## 2 2 John 110.84859 ## 3 3 순이 98.11399 ## 4 4 Paul 78.60413 ## 5 5 영희 88.77826 테이타프레임에서 하나의 벡터를 꺼내는 방법은 프레임이름뒤에 $ 를 붙이고 벡터의 변수명을 붙이면 된다. dat$Name ## [1] &quot;철이&quot; &quot;John&quot; &quot;순이&quot; &quot;Paul&quot; &quot;영희&quot; dat$Salary ## [1] 99.66793 110.84859 98.11399 78.60413 88.77826 데이타프레임의 자료의 일부를 추출하는 경우 행과 열의 위치를 지정하여 벡터와 유사하게 일부를 나타낼 수 있다. 그 형식은 dataframe[행의 위치, 열의 위치] 로 지정한다. dat[1,1] ## [1] 1 dat[3,2] ## [1] &quot;순이&quot; dat[10,1] ## [1] NA dat[3,] ## ID Name Salary ## 3 3 순이 98.11399 dat[,3] # dat$Salary와 같은 결과 ## [1] 99.66793 110.84859 98.11399 78.60413 88.77826 dat[1:3, c(1,3)] ## ID Salary ## 1 1 99.66793 ## 2 2 110.84859 ## 3 3 98.11399 R은 차제가 여러 가지 자료를 포함하고 있으서 자료의 이름을 입력하면 자료를 볼 수 있고 여러 가지 요약 통계를 볼수 있다. 아래에 나오는 cars라는 데이타프레임은 두 개의 벡터 dist와 speed를 포함하는 데이타프레임이다. cars데이타프레임은 자동차 운행시 브레이크를 밟았을 때 속도 speed에 따른 제동거리 dist를 실험으로 구성한 자료이다 (?cars를 이용하여 자료의 정보를 볼 수 있다) cars ## speed dist ## 1 4 2 ## 2 4 10 ## 3 7 4 ## 4 7 22 ## 5 8 16 ## 6 9 10 ## 7 10 18 ## 8 10 26 ## 9 10 34 ## 10 11 17 ## 11 11 28 ## 12 12 14 ## 13 12 20 ## 14 12 24 ## 15 12 28 ## 16 13 26 ## 17 13 34 ## 18 13 34 ## 19 13 46 ## 20 14 26 ## 21 14 36 ## 22 14 60 ## 23 14 80 ## 24 15 20 ## 25 15 26 ## 26 15 54 ## 27 16 32 ## 28 16 40 ## 29 17 32 ## 30 17 40 ## 31 17 50 ## 32 18 42 ## 33 18 56 ## 34 18 76 ## 35 18 84 ## 36 19 36 ## 37 19 46 ## 38 19 68 ## 39 20 32 ## 40 20 48 ## 41 20 52 ## 42 20 56 ## 43 20 64 ## 44 22 66 ## 45 23 54 ## 46 24 70 ## 47 24 92 ## 48 24 93 ## 49 24 120 ## 50 25 85 위에서 보았듯이 R은 계산과 분석에 필요한 기능을 함수(function)로 가지고 있으며 함수이름을 치고 괄호안에 필요한 정보를 넣으면 정보를 제공한다. 아래에서 head 함수는 자료의 앞부분만을 보는 기능을 하고 summary 함수는 자료 cars에 있는 변수들의 요약 통계량을 주는 기능을 가진다 head(cars) ## speed dist ## 1 4 2 ## 2 4 10 ## 3 7 4 ## 4 7 22 ## 5 8 16 ## 6 9 10 summary(cars) ## speed dist ## Min. : 4.0 Min. : 2.00 ## 1st Qu.:12.0 1st Qu.: 26.00 ## Median :15.0 Median : 36.00 ## Mean :15.4 Mean : 42.98 ## 3rd Qu.:19.0 3rd Qu.: 56.00 ## Max. :25.0 Max. :120.00 dim(cars) ## [1] 50 2 위에서 함수 dim은 데이타프레임에서 자료의 갯수(50개)와 변수의 개수(2개)를 벡터 형식으로 알려준다. 3.6 간단한 그림 그리기 cars자료에 있는 dist 벡터의 히스토그램과 상자그림은 각각 hist 와 boxplot 함수로 그릴 수 있다. hist(cars$dist) boxplot(cars$dist) 데이타프레임 전체에 plot함수를 적용하면 데이터프레임안에 있는 모든 변수들의 상자그림을 같이 그려준다. boxplot(cars) car자료에 있는 두 변수의 산포도를 보려면 다음과 같은 plot 함수를 이용하면 된다. plot 함수는 두 개의 인자(argument)를 plot(x,y)와 같이 요구하는데 첫 번째 인자는 x축으로 이용할 변수이고 두 번째 인자는 y 축으로 이용할 변수이다. plot(cars$speed, cars$dist) a &lt;- seq(5,10,0.1) a ## [1] 5.0 5.1 5.2 5.3 5.4 5.5 5.6 5.7 5.8 5.9 6.0 6.1 6.2 6.3 6.4 ## [16] 6.5 6.6 6.7 6.8 6.9 7.0 7.1 7.2 7.3 7.4 7.5 7.6 7.7 7.8 7.9 ## [31] 8.0 8.1 8.2 8.3 8.4 8.5 8.6 8.7 8.8 8.9 9.0 9.1 9.2 9.3 9.4 ## [46] 9.5 9.6 9.7 9.8 9.9 10.0 b &lt;- exp(a) b ## [1] 148.4132 164.0219 181.2722 200.3368 221.4064 244.6919 ## [7] 270.4264 298.8674 330.2996 365.0375 403.4288 445.8578 ## [13] 492.7490 544.5719 601.8450 665.1416 735.0952 812.4058 ## [19] 897.8473 992.2747 1096.6332 1211.9671 1339.4308 1480.2999 ## [25] 1635.9844 1808.0424 1998.1959 2208.3480 2440.6020 2697.2823 ## [31] 2980.9580 3294.4681 3640.9503 4023.8724 4447.0667 4914.7688 ## [37] 5431.6596 6002.9122 6634.2440 7331.9735 8103.0839 8955.2927 ## [43] 9897.1291 10938.0192 12088.3807 13359.7268 14764.7816 16317.6072 ## [49] 18033.7449 19930.3704 22026.4658 plot(a,b) "],["dataframe.html", "제 4 장 데이터 다루기 4.1 tidyr 패키지 4.2 gather() 4.3 spread() 4.4 dplyr 패키지와 연결 연산자 %&gt;% 4.5 select() 4.6 filter() 4.7 연결연산자 %&gt;%의 이용 4.8 arrange() 4.9 mutate() 4.10 group_by() 와 summarise() 4.11 join()", " 제 4 장 데이터 다루기 R 프로그램을 이용한 자료의 처리와 시각화의 기초를 다음의 3개의 패키지를 이용하여 알아보도록 하자. dplyr : R의 기본적인 data.frame에서 자료를 조건에 따라 선택하고, 배열하고, 결합하고, 요약하는데 편리한 함수을 제공하는 패키지이다. tidyr : 자료를 조건에 따라 배열을 바꾸는 함수를 제공하는 패키지이다. ggplot2 : 다양한 그림을 그리는데 유용한 패키지이다. 통계분석을 위하여 구성된 자료는 매우 다양한 형태를 가질 수 있다. 자료를 저장하는 형식은 자료를 구성하는 방법에 의해 매우 다르게 나타난다. 자료를 다음과 같이 간결하게 재구성하면 일관성있게 통계분석을 위한 함수를 사용할 수 있다. 다음은 자료를 재구성하는 경우의 원칙이다. 데이터 프레임의 각 열은 변수(variable, feature)를 나타낸다. 데이터 프레임의 각 행은 조사 또는 관측 단위(observation)을 나타낸다. 간결한 자료: tydy data 4.1 tidyr 패키지 tidyr 에 조건에 따라 자료를 재배치하는데 매우 유용한 패키지이다. 여러 개의 유용한 함수들중에서 가장 자주 사용되고 중요한 4개의 함수에 대하여 알아보기로 하자. 4.2 gather() gather() 함수는 여러 개의 변수(속성들)을 선택하여 변수의 속성(key)과 각 해당하는 자료의 값(value)를 두 개의 열로 길게 배열하는 함수이다. 간단한 예를 들면 전자판매점에서 3명의 점원이 판매한 3개의 품목의 수량을 나타내는 자료이다. sales &lt;- data.frame( person = c(&quot;John&quot;, &quot;Mary&quot;, &quot;Steve&quot;), tv = c(2, 1, 3), cellphone = c(20, 25, 30), computer = c(4, 4, 4) ) sales ## person tv cellphone computer ## 1 John 2 20 4 ## 2 Mary 1 25 4 ## 3 Steve 3 30 4 위의 sales 자료에서 tv, cellphone,computer 는 판매점에 진영된 여러 가지 품목(item)중의 하나이다. 또한 자료에 있는 숫자들은 각 품목을 판매한 수량(quantity)이다. 3개의 제품을 속성(key 또는 attribute)으로 가지는 품목을 새로운 변수 item 으로 만들고, 각 품목에 대한 판매 수량이 새로운 변수 quantity로 나타나는 자료를 다음과 같이 만들 수 있다. gathered_sales &lt;- gather(sales, item, quantity, tv, cellphone,computer) gathered_sales ## person item quantity ## 1 John tv 2 ## 2 Mary tv 1 ## 3 Steve tv 3 ## 4 John cellphone 20 ## 5 Mary cellphone 25 ## 6 Steve cellphone 30 ## 7 John computer 4 ## 8 Mary computer 4 ## 9 Steve computer 4 gather() 함수는 행으로 길게 늘어진 자료를 열로 길게 즐어지게 만드는 기능을 하는 함수이다. 4.3 spread() spread() 함수의 기능은 gether()함수와 반대되는 작업을 수행하는 함수로 2개의 열(하나는 속성, 다른 하나는 값) 선택하여 변수의 속성들을 변수들로 변환하여 해당하는 자료의 값 하나의 행으로 길게 배열하는 함수이다. 위에서 gather()함수로 변환된 자료를 spread() 함수를 이용하여 다시 원래 자료로 변화할 수 있다. spread_sales &lt;- spread(gathered_sales, item, quantity) spread_sales ## person cellphone computer tv ## 1 John 20 4 2 ## 2 Mary 25 4 1 ## 3 Steve 30 4 3 spread() 함수는 열으로 길게 늘어진 자료를 행로 길게 즐어지게 만드는 기능을 하는 함수이다. 4.4 dplyr 패키지와 연결 연산자 %&gt;% dplyr 패키지는 다음과 같은 기능을 가진 함수를 제공한다. select() 자료의 변수를 부분적으로 선택한다. filter() 자료를 일부를 주너진 조건에 따라서 선택한다. arrage() 자료(행)가 배열된 순서를 바꾼다. mutate() 새로운 변수를 만든다. group_by() 범주형 변수에 의하여 자료를 그룹으로 나눈다. summarise() 자료를 주어진 함수에 따라 요약한다. join() 두 개의 자료를 결합한다. dplyr 패키지에 있는 함수의 기능을 설명하기 위하여 hflight 패키지에 포함된 여객기의 비행기록자료를 사용해보자. library(hflights) data(hflights) head(hflights) ## Year Month DayofMonth DayOfWeek DepTime ArrTime UniqueCarrier FlightNum ## 5424 2011 1 1 6 1400 1500 AA 428 ## 5425 2011 1 2 7 1401 1501 AA 428 ## 5426 2011 1 3 1 1352 1502 AA 428 ## 5427 2011 1 4 2 1403 1513 AA 428 ## 5428 2011 1 5 3 1405 1507 AA 428 ## 5429 2011 1 6 4 1359 1503 AA 428 ## TailNum ActualElapsedTime AirTime ArrDelay DepDelay Origin Dest Distance ## 5424 N576AA 60 40 -10 0 IAH DFW 224 ## 5425 N557AA 60 45 -9 1 IAH DFW 224 ## 5426 N541AA 70 48 -8 -8 IAH DFW 224 ## 5427 N403AA 70 39 3 3 IAH DFW 224 ## 5428 N492AA 62 44 -3 5 IAH DFW 224 ## 5429 N262AA 64 45 -7 -1 IAH DFW 224 ## TaxiIn TaxiOut Cancelled CancellationCode Diverted ## 5424 7 13 0 0 ## 5425 6 9 0 0 ## 5426 5 17 0 0 ## 5427 9 22 0 0 ## 5428 9 9 0 0 ## 5429 6 13 0 0 4.5 select() select() 함수는 자료의 변수를 부분적으로 선택한다. 다음은 hflights자료에서 3개의 변수를 이름으로 선택하는 경우이다. head(select(hflights, DepTime, ArrTime, FlightNum)) ## DepTime ArrTime FlightNum ## 5424 1400 1500 428 ## 5425 1401 1501 428 ## 5426 1352 1502 428 ## 5427 1403 1513 428 ## 5428 1405 1507 428 ## 5429 1359 1503 428 다음은 변수들의 순서를 주거나 (var1:var2) 특정 문자가 변수명에 포함된 변수를 선택하는 경우이다. head(select(hflights, Year:Month, contains(&quot;time&quot;))) ## Year Month DepTime ArrTime ActualElapsedTime AirTime ## 5424 2011 1 1400 1500 60 40 ## 5425 2011 1 1401 1501 60 45 ## 5426 2011 1 1352 1502 70 48 ## 5427 2011 1 1403 1513 70 39 ## 5428 2011 1 1405 1507 62 44 ## 5429 2011 1 1359 1503 64 45 select() 함수는 starts_with(), ends_with(), matches() 그리고 contains()와 같은 도움 함수들을 이용하여 변수명을 선택할 수 있다. 4.6 filter() filter() 함수는 자료를 일부를 주너진 조건에 따라서 선택한다. hflights자료에서 12월 25일에 출발한 비행기만을 선택하는 조건을 다음과 같이 적용할 수 있다. head(filter(hflights, Month==12, DayofMonth==25)) ## Year Month DayofMonth DayOfWeek DepTime ArrTime UniqueCarrier FlightNum ## 1 2011 12 25 7 609 920 AA 466 ## 2 2011 12 25 7 1155 1317 AA 865 ## 3 2011 12 25 7 1739 2110 AA 1294 ## 4 2011 12 25 7 1339 1701 AA 1496 ## 5 2011 12 25 7 1437 1543 AA 1740 ## 6 2011 12 25 7 905 1020 AA 1788 ## TailNum ActualElapsedTime AirTime ArrDelay DepDelay Origin Dest Distance ## 1 N3FKAA 131 115 0 9 IAH MIA 964 ## 2 N4WTAA 82 40 12 0 IAH DFW 224 ## 3 N3CEAA 151 114 10 4 IAH MIA 964 ## 4 N3CPAA 142 114 11 14 IAH MIA 964 ## 5 N528AA 66 39 -7 -3 IAH DFW 224 ## 6 N4YNAA 75 39 0 0 IAH DFW 224 ## TaxiIn TaxiOut Cancelled CancellationCode Diverted ## 1 5 11 0 0 ## 2 9 33 0 0 ## 3 26 11 0 0 ## 4 9 19 0 0 ## 5 11 16 0 0 ## 6 8 28 0 0 두 조건을 OR 로 하여 자료의 일부를 선택하려면 | 연산자를 이용한다. filter(hflights, UniqueCarrier==&quot;AA&quot; | UniqueCarrier==&quot;UA&quot;) %&gt;% head() ## Year Month DayofMonth DayOfWeek DepTime ArrTime UniqueCarrier FlightNum ## 1 2011 1 1 6 1400 1500 AA 428 ## 2 2011 1 2 7 1401 1501 AA 428 ## 3 2011 1 3 1 1352 1502 AA 428 ## 4 2011 1 4 2 1403 1513 AA 428 ## 5 2011 1 5 3 1405 1507 AA 428 ## 6 2011 1 6 4 1359 1503 AA 428 ## TailNum ActualElapsedTime AirTime ArrDelay DepDelay Origin Dest Distance ## 1 N576AA 60 40 -10 0 IAH DFW 224 ## 2 N557AA 60 45 -9 1 IAH DFW 224 ## 3 N541AA 70 48 -8 -8 IAH DFW 224 ## 4 N403AA 70 39 3 3 IAH DFW 224 ## 5 N492AA 62 44 -3 5 IAH DFW 224 ## 6 N262AA 64 45 -7 -1 IAH DFW 224 ## TaxiIn TaxiOut Cancelled CancellationCode Diverted ## 1 7 13 0 0 ## 2 6 9 0 0 ## 3 5 17 0 0 ## 4 9 22 0 0 ## 5 9 9 0 0 ## 6 6 13 0 0 4.7 연결연산자 %&gt;%의 이용 위의 프로그램에서 앞에서와 다르게 head()함수를 head(filter(....))와 같이 축차적으로 사용하지 않고 연산자 %&gt;% 뒤에 인자없이 사용하였다. 연산자 %&gt;%는 연결 연산자(pipe operator)라고 하며 함수를 축차적으로 연속하여 사용하지 않고 왼쪽에서 생성된 자료를 오른쪽 함수의 인자로 전달 해주는 역활을 하는 유용한 연산자이며 이를 이용하려면 tidyr 패키지를 로딩해야 한다. 예를 들어 hflights자료에서 12월 25일에 출발한 비행기만을 선택하고 다시 몇 개의 변수만 선택하여 자료의 앞부분만 보여주고 싶다면 다음과 같이 연결 연산자를 이용하여 실행할 수 있다. filter(hflights, Month==12, DayofMonth==25) %&gt;% select(DepTime, ArrTime, FlightNum, contains(&quot;Month&quot;)) %&gt;% head() ## DepTime ArrTime FlightNum Month DayofMonth ## 1 609 920 466 12 25 ## 2 1155 1317 865 12 25 ## 3 1739 2110 1294 12 25 ## 4 1339 1701 1496 12 25 ## 5 1437 1543 1740 12 25 ## 6 905 1020 1788 12 25 위에서 연결 연산자를 이용하여 실행한 명령어는 다음 명령어의 결과와 같다. t1 &lt;- filter(hflights, Month==12, DayofMonth==25) t2 &lt;- select(t1, DepTime, ArrTime, FlightNum, contains(&quot;Month&quot;)) head(t2) ## DepTime ArrTime FlightNum Month DayofMonth ## 1 609 920 466 12 25 ## 2 1155 1317 865 12 25 ## 3 1739 2110 1294 12 25 ## 4 1339 1701 1496 12 25 ## 5 1437 1543 1740 12 25 ## 6 905 1020 1788 12 25 4.8 arrange() arrage() 함수는 자료의 행이 배열된 순서를 선택된 변수의 배열(오름차순 또는 내림차순)로 바꾼다. hflights 자료에서 두 변수 TailNum와 ArrDelay만을 선택하고 ArrDelay의 자료의 오름차순으로 다시 배열하려면 다음과 같은 명령어를 사용한다. hflights %&gt;% select(TailNum, ArrDelay) %&gt;% arrange(ArrDelay) %&gt;% head() ## TailNum ArrDelay ## 1 N12157 -70 ## 2 N814SK -57 ## 3 N767SK -56 ## 4 N783SK -56 ## 5 N713SK -55 ## 6 N37437 -55 ArrDelay의 자료의 오름차순으로 다시 배열하려면 desc() 도움함수를 사용한다. hflights %&gt;% select(TailNum, ArrDelay) %&gt;% arrange(desc(ArrDelay)) %&gt;% head() ## TailNum ArrDelay ## 1 N473AA 978 ## 2 N69063 957 ## 3 N502MQ 918 ## 4 N670UA 861 ## 5 N609MQ 822 ## 6 N6EAMQ 793 4.9 mutate() mutate() 함수는 새로운 변수를 생성하는 함수이다. 예를 들어 hflight자료에서 새로운 변수 비행기의 속도(AirSpeed)를 계산하려면 비행거리(Distance)를 비행시간(AirTime)으로 나누어야 한다. mutate() 함수를 이용하면 두 개 이상의 새로운 변수를 사용할 수 있다. mutate(hflights, Speed = Distance/AirTime*69, SpeedKM = Speed*1.60934) %&gt;% head() ## Year Month DayofMonth DayOfWeek DepTime ArrTime UniqueCarrier FlightNum ## 5424 2011 1 1 6 1400 1500 AA 428 ## 5425 2011 1 2 7 1401 1501 AA 428 ## 5426 2011 1 3 1 1352 1502 AA 428 ## 5427 2011 1 4 2 1403 1513 AA 428 ## 5428 2011 1 5 3 1405 1507 AA 428 ## 5429 2011 1 6 4 1359 1503 AA 428 ## TailNum ActualElapsedTime AirTime ArrDelay DepDelay Origin Dest Distance ## 5424 N576AA 60 40 -10 0 IAH DFW 224 ## 5425 N557AA 60 45 -9 1 IAH DFW 224 ## 5426 N541AA 70 48 -8 -8 IAH DFW 224 ## 5427 N403AA 70 39 3 3 IAH DFW 224 ## 5428 N492AA 62 44 -3 5 IAH DFW 224 ## 5429 N262AA 64 45 -7 -1 IAH DFW 224 ## TaxiIn TaxiOut Cancelled CancellationCode Diverted Speed SpeedKM ## 5424 7 13 0 0 386.4000 621.8490 ## 5425 6 9 0 0 343.4667 552.7546 ## 5426 5 17 0 0 322.0000 518.2075 ## 5427 9 22 0 0 396.3077 637.7938 ## 5428 9 9 0 0 351.2727 565.3173 ## 5429 6 13 0 0 343.4667 552.7546 새로 생성된 변수만 선택하고 싶다면 transmute()함수를 사용한다. transmute(hflights, Speed = Distance/AirTime*69, SpeedKM = Speed*1.60934) %&gt;% head() ## Speed SpeedKM ## 5424 386.4000 621.8490 ## 5425 343.4667 552.7546 ## 5426 322.0000 518.2075 ## 5427 396.3077 637.7938 ## 5428 351.2727 565.3173 ## 5429 343.4667 552.7546 4.10 group_by() 와 summarise() 통계분석에서 범주(categorical variable)에 따라 자료의 요약을 하는 것은 매우 흔한 일이다. group_by() 함수는 자료를 선택된 범주형 변수에 의하여 묶어주는 기능을 하며 group_by() 함수는 특별한 결과를 생성하지 않고 자료(dataframe)에 그룹에 대한 정보를 저장한다. group_by() 에 의하여 그룹이 생성된 자료(dataframe)에 summarise()를 이용하여 통계 함수를 적용하면 지정된 그룹별로 요약 통계량이 기술된다. 다음의 예는 hflight 자료에서 도착공항별(Dest)로 도착이 지연된 시간(ArrDelay)의 평균을 구하는 명령어이다. groupdata &lt;- group_by(hflights, Dest) summarise(groupdata, avg_delay = mean(ArrDelay, na.rm=TRUE)) ## # A tibble: 116 × 2 ## Dest avg_delay ## &lt;chr&gt; &lt;dbl&gt; ## 1 ABQ 7.23 ## 2 AEX 5.84 ## 3 AGS 4 ## 4 AMA 6.84 ## 5 ANC 26.1 ## 6 ASE 6.79 ## 7 ATL 8.23 ## 8 AUS 7.45 ## 9 AVL 9.97 ## 10 BFL -13.2 ## # … with 106 more rows 위의 명령어는 다음 명령어와 같은 결과를 준다. hflights %&gt;% group_by(Dest) %&gt;% summarise(avg_delay = mean(ArrDelay, na.rm=TRUE)) ## # A tibble: 116 × 2 ## Dest avg_delay ## &lt;chr&gt; &lt;dbl&gt; ## 1 ABQ 7.23 ## 2 AEX 5.84 ## 3 AGS 4 ## 4 AMA 6.84 ## 5 ANC 26.1 ## 6 ASE 6.79 ## 7 ATL 8.23 ## 8 AUS 7.45 ## 9 AVL 9.97 ## 10 BFL -13.2 ## # … with 106 more rows 물론 그룹을 지정하지 않고 전체 자료의 통계도 구할 수 있다. summarise(hflights,avg_delay = mean(ArrDelay, na.rm=TRUE)) ## avg_delay ## 1 7.094334 또한 다음과 같이 여러 개의 통계량을 동시에 구할 수 있다. groupdata &lt;- group_by(hflights, Dest) summarise(groupdata, avg_delay = mean(ArrDelay, na.rm=TRUE), count = n(), dist = mean(Distance, na.rm = TRUE), delay = mean(ArrDelay, na.rm = TRUE)) ## # A tibble: 116 × 5 ## Dest avg_delay count dist delay ## &lt;chr&gt; &lt;dbl&gt; &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 ABQ 7.23 2812 749. 7.23 ## 2 AEX 5.84 724 190 5.84 ## 3 AGS 4 1 821 4 ## 4 AMA 6.84 1297 518. 6.84 ## 5 ANC 26.1 125 3266 26.1 ## 6 ASE 6.79 125 914. 6.79 ## 7 ATL 8.23 7886 692. 8.23 ## 8 AUS 7.45 5022 143. 7.45 ## 9 AVL 9.97 350 834 9.97 ## 10 BFL -13.2 504 1428 -13.2 ## # … with 106 more rows 여러 개의 변수에 같은 함수를 동시에 적용하려면 summarise_at() 함수를 사용한다. 다음은 공항별로 2개의 변수( ArrDelay, DepDelay)의 평균, 최소, 최대값을 구하는 명령어이다. group_by(hflights, Dest) %&gt;% summarise_at( c(&quot;ArrDelay&quot;, &quot;DepDelay&quot;), funs(mean(., na.rm=TRUE), min (., na.rm=TRUE), max(., na.rm=TRUE))) ## Warning: `funs()` was deprecated in dplyr 0.8.0. ## Please use a list of either functions or lambdas: ## ## # Simple named list: ## list(mean = mean, median = median) ## ## # Auto named with `tibble::lst()`: ## tibble::lst(mean, median) ## ## # Using lambdas ## list(~ mean(., trim = .2), ~ median(., na.rm = TRUE)) ## This warning is displayed once every 8 hours. ## Call `lifecycle::last_lifecycle_warnings()` to see where this warning was generated. ## # A tibble: 116 × 7 ## Dest ArrDelay_mean DepDelay_mean ArrDelay_min DepDelay_min ArrDelay_max ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; ## 1 ABQ 7.23 8.48 -26 -14 290 ## 2 AEX 5.84 6.38 -34 -17 257 ## 3 AGS 4 10 4 10 4 ## 4 AMA 6.84 6.70 -28 -13 301 ## 5 ANC 26.1 25.0 -21 -6 281 ## 6 ASE 6.79 16.0 -31 -33 252 ## 7 ATL 8.23 10.3 -41 -17 701 ## 8 AUS 7.45 8.42 -24 -15 244 ## 9 AVL 9.97 8.90 -23 -10 331 ## 10 BFL -13.2 5.06 -56 -13 206 ## # … with 106 more rows, and 1 more variable: DepDelay_max &lt;int&gt; 위에서 함수 summarise의 결과는 dataframe보다 자료 저장의 형식이 개선된 tibble 형식으로 표시된다. 4.11 join() join() 함수는 두 자료(dataframe)를 선택된 공통의 범주형 변수에 의거하여 결합한다. 결합하는 경우 두 개의 인자의 위치에 따른 4가지의 결합기준을 이용할 수 있다. left_join 왼쪽 자료의 항목을 기준으로 결합 right_join 오른쪽 쪽 자료의 항목을 기준으로 결합 inner_join 두 자료의 공통 항목만을 결합 full_join 두 자료의 모든 항목을 결합 다음과 같은 두 개의 자료(dataframe)을 이용하여 자료를 결합할 때 4가지 기분의 차이점을 살펴보자. Ldata &lt;- data.frame(ID=c(&quot;A&quot;,&quot;B&quot;,&quot;C&quot;), x=c(1,2,3)) Rdata &lt;- data.frame(ID=c(&quot;A&quot;,&quot;B&quot;,&quot;D&quot;), y=c(T,F,T)) Ldata ## ID x ## 1 A 1 ## 2 B 2 ## 3 C 3 Rdata ## ID y ## 1 A TRUE ## 2 B FALSE ## 3 D TRUE left_join(Ldata,Rdata,by=&quot;ID&quot;) ## ID x y ## 1 A 1 TRUE ## 2 B 2 FALSE ## 3 C 3 NA right_join(Ldata,Rdata,by=&quot;ID&quot;) ## ID x y ## 1 A 1 TRUE ## 2 B 2 FALSE ## 3 D NA TRUE inner_join(Ldata,Rdata,by=&quot;ID&quot;) ## ID x y ## 1 A 1 TRUE ## 2 B 2 FALSE full_join(Ldata,Rdata,by=&quot;ID&quot;) ## ID x y ## 1 A 1 TRUE ## 2 B 2 FALSE ## 3 C 3 NA ## 4 D NA TRUE "],["external.html", "제 5 장 외부자료 5.1 예제: 엑셀 화일의 구성 5.2 패키지의 설치와 이용 지정 5.3 엑셀 화일의 입력 5.4 CSV 화일의 입력", " 제 5 장 외부자료 5.1 예제: 엑셀 화일의 구성 MS 엑셀화일(Miscrosoft Excel file)은 자료를 저장하고 정리하는데 매우 유용한 프로그램이다. 이번에는 R에서 MS 엑셀화일을 불러들여서 데이카프레임 형식으로 저장하는 방법을 소개한다. 아래 그림과 같이 2014-2018년의 서울시 구별 인구정보가 test.xlsx 엑셀 화일에 저장되어 있다고 가정하자. 첫 번째 줄은 각 열을 설명하는 변수의 이름이며 영어문자로 구성되어 있다. 5개의 변수로 구성된 자료이다. (year, name, house, pop, old65) year: 년도 name : 구이름 house: 가구수 pop : 인구수 old65: 65세 이상 인구수 한 개의 sheet만 있는 화일이다 (참고로 MS 엑셀화일은 여러 개의 sheet으로 구성될 수 있다.) 그림 5.1: 2018년 서울시 구별 인구 엑셀 화일 5.2 패키지의 설치와 이용 지정 5.2.1 패키지 readxl의 설치 R은 독자적으로도 여러 가지 다양한 기능을 수행할 수 있는 통계 프로그램이지만 다양한 기능을 제공하는 패키지(poackage)를 설치하면 더욱 편리한 기능을 이용할 수 있다. MS 엑셀화일은 여러 가지 형식(xls, xlsx, csv, …)이 있기 때문에 엑셀화일을 수월하게 읽을 수 있는 패키지 readxl을 설치하여 이용하면 쉽게 엑셀화일의 자료를 데이터프레임으로 변환하여 사용할 수 있다. 패키지의 설치는 두 가지 방법이 있다. plot 패널에서 packages 탭을 클릭하면 install 버튼이 있다. install 버튼을 클릭하면 대화창이 뜨고 설치하고자 하는 패키지의 이름을 입력하여 선택한다. 아래 있는 install 버튼을 클릭하면 패키지를 설치해 준다. 그림 5.2: Rstudio에서 패키지 설치 R의 console화면에서 명령어 install.packages 함수를 이용하여 설치한다. install.packages(&quot;readxl&quot;) 5.2.2 패키지의 지정 패키지 readxl을 설치한 후 그 기능을 이용하고 싶다면 다음과 같이 library 함수를 사용하여 패키지를 지정해 주어야 한다. library(readxl) 참고로 패키지의 설치는 최초 한 번만 해주면된다. 하지만 library 함수를 이용한 패키지의 지정은 사용할 때마다 실행해 주어야 한다. 5.3 엑셀 화일의 입력 5.3.1 working directory 지정 이제 test.xlsx 엑셀 화일을 원하는 디렉토리에 저장한다. 화일을 저장한 디렉토리를 working directory로 지정해 주어야 한다. Rstudio 메뉴에서 session을 선택하면 set working directory 메뉴가 있다. choose directory를 선택하고 test.xlsx 엑셀 화일을 저장한 디렉토리를 지정해 준다. 5.3.2 엑셀 화일의 입력 test.xlsx 엑셀 화일의 자료를 데이터프레임 seoulpop01 에 저장해 주려면 다음과 같은 명령어를 실행한다. seoulpop01 &lt;- read_excel(&quot;./data/test.xlsx&quot;, col_names = TRUE) seoulpop01 ## # A tibble: 130 × 5 ## year name house pop old65 ## &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 2014 합계 4194176 10369593 1221616 ## 2 2014 종로구 73101 165344 24537 ## 3 2014 중구 59960 136227 19960 ## 4 2014 용산구 108429 249914 34896 ## 5 2014 성동구 125814 303891 36684 ## 6 2014 광진구 158524 377375 38974 ## 7 2014 동대문구 159880 376319 50915 ## 8 2014 중랑구 176714 423411 51995 ## 9 2014 성북구 193359 475961 62066 ## 10 2014 강북구 141246 338410 50841 ## # … with 120 more rows 위에서 엑셀 화일을 읽을 때 다음과 같은 점을 유의하자. 위에서 사용한 함수 read_excel은 패키지 readxl을 설치해야 사용할 수 있는 함수이다. 함수 read_excel는 컴마로 분리된 두 가지 인자(arguments)를 받는다. 첫 번째 인자는 문자열로 된 엑셀 화일의 이름이다(\"test.xlsx\"). 두 번째 인자 col_names = TRUE 는 선택 명령어(options)이며 엑셀 화일 \"test.xlsx\"에서 첫 행이 자료가 아니고 변수의 이름이라는 것을 알려주는 문장이다. 만약 엑셀 화일의 첫 행부터 자료가 시작된다면 col_names = FALSE 라고 지정해야 한다. seoulpop01은 데이터프레임 형식이 아닌 tibble 형식이며 이는 데이터프레임의 보다 진화된 형식이라고 볼 수 있다. tibble 형식의 seoulpop01을 데이터프레임 형식인 seoulpop02으로 함수 data.frame 함수를 이용하여 저장하자. seoulpop02 &lt;- data.frame(seoulpop01) head(seoulpop02, n=30) ## year name house pop old65 ## 1 2014 합계 4194176 10369593 1221616 ## 2 2014 종로구 73101 165344 24537 ## 3 2014 중구 59960 136227 19960 ## 4 2014 용산구 108429 249914 34896 ## 5 2014 성동구 125814 303891 36684 ## 6 2014 광진구 158524 377375 38974 ## 7 2014 동대문구 159880 376319 50915 ## 8 2014 중랑구 176714 423411 51995 ## 9 2014 성북구 193359 475961 62066 ## 10 2014 강북구 141246 338410 50841 ## 11 2014 도봉구 136977 355712 46471 ## 12 2014 노원구 221107 586056 66480 ## 13 2014 은평구 202187 503243 67002 ## 14 2014 서대문구 134780 320861 45309 ## 15 2014 마포구 169492 395830 47360 ## 16 2014 양천구 179069 490708 48175 ## 17 2014 강서구 234378 591653 64287 ## 18 2014 구로구 172594 457131 51187 ## 19 2014 금천구 103940 258030 29553 ## 20 2014 영등포구 168100 421436 49829 ## 21 2014 동작구 172389 419261 52327 ## 22 2014 관악구 248180 531960 62577 ## 23 2014 서초구 173469 454288 47469 ## 24 2014 강남구 237375 583446 57444 ## 25 2014 송파구 257207 671794 65025 ## 26 2014 강동구 185905 481332 50253 ## 27 2015 합계 4189948 10297138 1267563 ## 28 2015 종로구 72645 163822 24892 ## 29 2015 중구 59321 134329 20302 ## 30 2015 용산구 107512 247909 35715 5.4 CSV 화일의 입력 많은 경우 자료가 CSV(comma-separated values)화일로 저장된다. CSV 화일은 자료의 값(필드)를 쉼표(,) 또는 여백(space)로 구분한 텍스트 데이터 및 텍스트 파일이다. 확장자는 .csv 이며 이 화일은 MS Excel 프로그램으로 볼 수 있다. 예제 화일인 seoulpopall.csv의 실제 내용을 보면 다음과 같다. year,name,house,pop,popm,popf,for,density,area,numhouse,old65 1991,합계,3330317,10904527,5485353,5419174,,18014,605.33,3.27, 1991,종로구,78169,236806,119127,117679,,9865,24.01,3.03, 1991,중구,61495,184142,93312,90830,,18438,9.99,2.99, CSV 화일은 R 에서 함수 read.table를 이용하여 자료를 불러 올 수 있다. 아래는 seoulpopall.csv 화일의 자료를 불러오는 R 명령어이다. df &lt;- read.table(&quot;./data/seoulpopall.csv&quot;, sep=&quot;,&quot;, header = TRUE, fileEncoding = &quot;CP949&quot;) 함수 read.table의 세가지 인자를 설명하면 다음과 같다. \"seoulpopall.csv\": 문자열로 된 csv 화일 이름 sep=\",\" : 각 변수의 필드가 쉼표(,)로 분리된 것을 지정한다. 만약 여백(space)으로 구분되어 있다면 sep=\"\"로 지정한다. header = TRUE : 첫 행이 자료가 아니고 변수의 이름이라는 것을 알려주는 문장이다. 아래는 seoulpopall.csv 화일의 자료가 저장된 데이터프레임 df의 내용이다. 자료 중에 NA로 표시된 부분은 자료가 없는 것, 즉 결측값(missing value, Not Available)을 의미 한다. head(df) ## year name house pop popm popf foreign density area ## 1 1991 합계 3330317 10904527 5485353 5419174 NA 18014 605.33 ## 2 1991 종로구 78169 236806 119127 117679 NA 9865 24.01 ## 3 1991 중구 61495 184142 93312 90830 NA 18438 9.99 ## 4 1991 용산구 96696 294341 147914 146427 NA 13460 21.87 ## 5 1991 성동구 244272 789014 401375 387639 NA 23273 33.90 ## 6 1991 동대문구 149914 479776 242828 236948 NA 32477 14.77 ## numhouse old65 ## 1 3.27 NA ## 2 3.03 NA ## 3 2.99 NA ## 4 3.04 NA ## 5 3.23 NA ## 6 3.20 NA "],["404.html", "Page not found", " Page not found The page you requested cannot be found (perhaps it was moved or renamed). You may want to try searching to find the page's new location, or use the table of contents to find the page you are looking for. "]]
